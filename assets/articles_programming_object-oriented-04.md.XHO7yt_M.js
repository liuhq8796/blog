import{_ as a,o as e,c as t,U as r}from"./chunks/framework.CPG1oFOX.js";const u=JSON.parse('{"title":"面向对象——04.基于接口而非实现编程","description":"","frontmatter":{},"headers":[],"relativePath":"articles/programming/object-oriented-04.md","filePath":"articles/programming/object-oriented-04.md","lastUpdated":1704195406000}'),o={name:"articles/programming/object-oriented-04.md"},i=r('<h1 id="面向对象——04-基于接口而非实现编程" tabindex="-1">面向对象——04.基于接口而非实现编程 <a class="header-anchor" href="#面向对象——04-基于接口而非实现编程" aria-label="Permalink to &quot;面向对象——04.基于接口而非实现编程&quot;">​</a></h1><h2 id="如何解读原则中的-接口-二字" tabindex="-1">如何解读原则中的“接口”二字？ <a class="header-anchor" href="#如何解读原则中的-接口-二字" aria-label="Permalink to &quot;如何解读原则中的“接口”二字？&quot;">​</a></h2><p>“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。</p><h2 id="如何将这条原则应用到实战中" tabindex="-1">如何将这条原则应用到实战中？ <a class="header-anchor" href="#如何将这条原则应用到实战中" aria-label="Permalink to &quot;如何将这条原则应用到实战中？&quot;">​</a></h2><p>我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。</p><p>“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。</p><h2 id="是否需要为每个类定义接口" tabindex="-1">是否需要为每个类定义接口？ <a class="header-anchor" href="#是否需要为每个类定义接口" aria-label="Permalink to &quot;是否需要为每个类定义接口？&quot;">​</a></h2><p>这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。</p><p>从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。</p><p>除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投入不必要的开发时间。</p>',10),n=[i];function c(s,d,l,p,_,h){return e(),t("div",null,n)}const b=a(o,[["render",c]]);export{u as __pageData,b as default};
