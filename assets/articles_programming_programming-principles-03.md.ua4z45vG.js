import{_ as a,o as e,c as r,U as t}from"./chunks/framework.2ESA56TH.js";const g=JSON.parse('{"title":"设计原则——03.接口隔离原则","description":"","frontmatter":{},"headers":[],"relativePath":"articles/programming/programming-principles-03.md","filePath":"articles/programming/programming-principles-03.md","lastUpdated":1706893786000}'),i={name:"articles/programming/programming-principles-03.md"},o=t('<h1 id="设计原则——03-接口隔离原则" tabindex="-1">设计原则——03.接口隔离原则 <a class="header-anchor" href="#设计原则——03-接口隔离原则" aria-label="Permalink to &quot;设计原则——03.接口隔离原则&quot;">​</a></h1><h2 id="如何理解-接口隔离原则" tabindex="-1">如何理解“接口隔离原则”？ <a class="header-anchor" href="#如何理解-接口隔离原则" aria-label="Permalink to &quot;如何理解“接口隔离原则”？&quot;">​</a></h2><p>理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p><p>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p><p>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。</p><h2 id="接口隔离原则与单一职责原则的区别" tabindex="-1">接口隔离原则与单一职责原则的区别 <a class="header-anchor" href="#接口隔离原则与单一职责原则的区别" aria-label="Permalink to &quot;接口隔离原则与单一职责原则的区别&quot;">​</a></h2><p>单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>',8),n=[o];function p(s,c,l,_,m,d){return e(),r("div",null,n)}const f=a(i,[["render",p]]);export{g as __pageData,f as default};
