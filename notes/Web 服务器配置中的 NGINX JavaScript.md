# Web 服务器配置中的 NGINX JavaScript

NJS 的目标是成为一个通用的 nginx 脚本框架，正如它的名字是 nginx 和 JavaScript 的混合词，NJS 结合了两者， 成为了一个从头编写了 JavaScript 解释器的 nginx 模块。

介绍下本文大纲，第一部分将谈论 nginx 脚本化配置的历史；第二章将是关于项目目标，NJS 的目标是什么，它要解决什么以及它不想解决什么；下一张将要谈论 NJS 解决这些问题的方式以及它的实现方式；下一章将展示如何在 nginx 中使用 NJS 的示例；最后再来谈谈 NJS 未来的计划和所有可用的功能。

好了，大纲已经介绍完了，那么我们从 nginx 脚本化配置的历史开始。

## NGINX 脚本化配置的历史

想要了解 nginx 脚本化配置的历史，从 nginx 团队对理想中的原生脚本的想法入手显然很有用，所以让我们来看看这些设想中的特性。

### 理想中的脚本特性

- 够快够轻量
  - 否则可以使用更高级的替代方案，例如 Node.js
- 与nginx的异步特性很好地集成
- 模块化
  - 不需要它的人可以禁用它来压榨更多的性能
- 流行的脚本语言
  - 帮助人们更快的编写他们的脚本

第一点也是重要的一点就是要够轻量够快，人类乐于使用 nginx 就是因为它速度快并且十分轻量，如果新脚本做不到这一点那还有什么意义，完全可以使用其他更高级的代替方案，例如 Node.js

第二点，理想的脚本语法应该能与nginx的异步特性很好地集成，由 nginx 负责进程的主要事件循环而不是其他。

下一点是关于模块化，它必须能够被禁用，以便不需要它的人可以禁用它来压榨更多的性能

最后，它应该是一种流行的脚本语言，可以帮助人们更快地编写他们的脚本，而不用去学习一门新语言，毕竟平时人们都有其他事情要做

### 关于 Perl

优势
- 可以使用现有的 Perl 库
- Perl代码可以嵌入到nginx 配置文件中

劣势
- 不支持非阻塞 IO
- Perl 解释器会退出工作进程

第一次尝试在 nginx 中实现原生脚本是在 2005 年，nginx 支持了 perl 语言模块，那么来了解一下 perl 与刚才提到的理想中的脚本语言有多少一致性

perl 模块第一大优势是可以使用现有的 Perl 库，这对于脚本来说是一个很大的优势。

第二点是 Perl 代码可以直接嵌入到nginx 的配置文件中，这种便利性是显而易见的

现在再来谈谈关于 perl 的负面评价

首先是它不支持非阻塞 IO，这是因为 perl 的解释器不知道它是在 nginx 中工作的，所以它会阻塞操作，显然这点对 nginx 来说是不可接受的，这是 perl 模块的很大的一个问题。

下一点是关于 perl 脚本本身，当他发生错误时会退出整个工作进程，这显然也是不可接受的。

## 设计目标

**现代化，快速的，针对 NGINX 运行时量身定制的高级脚本**

好，我们完成了 nginx 脚本化配置历史的部分，现在来继续第二部分。NJS 的目标是什么，nginx 团队试图用 NJS 模块解决什么问题。

NJS 的最终目的主要是减少 nginx 用户使用 C 语言编写新模块的必要性，毕竟开发 C 语言模块对新手甚至是有经验的开发人员来说也是一件困难的事情，尤其在时间紧张的时期更不值得这样去做。

所以再让我们更详细的看一下这些设计目标。

- 快速和轻量
  - njs 不应该过度降低nginx的性能
  - 内存/CPU 开销不应很大

- 安全性/健壮性
  - 每个请求都应与其他请求隔离

- 流行的脚本语言

首先第一点，它应该是快速和轻量的，使用njs不能拖慢nginx本身的速度，所以它也不应该有很大的CPU和内存开销，只为了能够在单个工作进程中处理大量的请求，就像nginx本身一样。

第二点是关于安全性和健壮性，这个想法意味着每个请求都应该在它自己的与其他请求隔离的上下文中执行，至少有两个原因来做这件事，第一个原因是关于安全性，为了让你的代码与其他人编写的代码相隔离，将来你只需插入代码即可或为了其他事情而开发它。第二点关于健壮性，如果你有一个独立的上下文，那么你可以毫无问题地处理给定连接的特殊情况而不会影响其他连接。

最后再次提到的一点是要用流行的脚本语言，因为当你想要解决一些特定问题的时候，人们不想把时间花在学习新语言上。

### 为什么是 JavaScript？

现在给你一些决定选择 JavaScript 的原因

- 现代通用语言
  - 因此，人们可以快速地理解它
- 类 C 语法
  - 与 nginx 配置文件良好匹配
- 事件驱动对于 JavaScript 来说是很自然的
  - 与 nginx 运行时完美匹配

JavaScript 的第一个大优点是 JavaScript 是一种现代通用语言，如果不是这一点，很可能就不会用 JavaScript 来扩展 nginx 了。

第二个优点是，JavaScript 有类似 C 的语法，这对于许多开发人员和 DevOps 来说是非常熟悉的，另外，对于 JavaScript 来说额外的一大优点是 JavaScript 有花括号来标记块，所以它与 nginx 配置的编写方式很好的对齐，所以在未来 JavaScript 也许可以直接注入到 nginx 配置文件中，这样他将成为一个有用的特性。

最后一点要提到的是 JavaScript 是为浏览器编写的，所以事件驱动对于 JavaScript 来说是很自然的，它内置于 JavaScript 中，因此该特性与 nginx 运行时完美匹配，因为 nginx 本身也是关于事件循环、回调以及类似的东西。

### 为什么要自己实现解释器

下面是为什么 nginx 团队要自己实现解释器的原因。

- V8/SpiderMonkey 在 nginx 中使用的话太重了
  - 复杂的引擎，对 nginx 来说有太多不必要的开销
- Duktape 对于 nginx 内部的任务来说不够快
  - 具有不同的优先级。更重视内存占用和 ECMAScript 规范一致性，而不是性能
- 自定义解释器可以针对 nginx 运行时进行定制

第一个原因是是，因为现有的 JavaScript 引擎，像 V8 和 SpiderMokey 一样先进的 JavaScript 引擎都太重了，而不能在 nginx 中使用它们。很明显他们是为不同的任务而设计的，他们被设计为在浏览器中执行，他们有各种各样的渲染引擎、垃圾收集器等等现代浏览器需要的所有东西，这是相当多的，但在 nginx 上的服务器端配置中，情况相当不同，你不需要很多额外的东西。

第二个代替方案是 Duktape，Duktape 是一个可以嵌入的 JavaScript 的引擎，可以嵌入到 C 和 C++ 语言中，他非常成熟，具有很多功能。但 Duktape 的问题在于它具有不同的优先级，更重视内存占用和 ECMAScript 规范一致性以及所有在它的优先级中比性能更重要的东西。这个对 nginx 来说不是一件好事，因为对于 nginx 我们更想要的是速度。

最后，当自己实现解释器时，你可以根据你的执行环境对其进行定制，这样就是一件非常有用的事情，因为当你拥有自己的解释器时，你可以对其进行自定义。至于自定义可以做什么，以下面这张图为例子。

**每秒创建上下文次数**

![每秒创建上下文次数](../imgs/created-contexts-sec.png)

这是每秒创建上下文的数量对比，截图来自2018年 nginx 团队的分享，你可以看到 NJS 创建上下文的速度至少比其他引擎快了两个个数量级。

原因很简单，不是什么魔法，只是 NJS 被设计为针对上下文创建时间进行了优化。对于 V8 和 SpiderMonkey 这样的浏览器引擎来说，引入一些延迟来处理 JavaScript 代码例如运行JIT编译器是完全可以接受的，但对于运行在服务器端的 NJS 来说情况完全不同，对于一个给定的请求路径，他所要运行的代码是相同的，因此可以预编译代码，可以剥离任何不需要的功能，可以优化上下文创建时间，这就是为什么我们看到这样的数字。

## NJS interpreter

那么接下来就将展示 NJS 如何实现前面描述的目标。

## Using NJS in nginx

## Plans for the future and available functionality
